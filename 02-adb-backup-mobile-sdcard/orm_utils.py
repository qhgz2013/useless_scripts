# Object Relation Mapping for database
# Version 1.3
# Providing basic entity class and various table field descriptors, all sql statement can be generated by this mechanism
# automatically, including CREATE TABLE, SELECT, UPDATE, INSERT, DELETE based on given primary key.
# CHANGELOG
# Ver 1.3: changed default value of TableFieldDescriptor behavior
# Ver 1.2: Support entity comparison, moved field cache to class initialization stage, minor bug fixed for member
#   injection
# Ver 1.1: added auto-complement of __TABLE_NAME__ field, default to the name of corresponding entity class, obeying
#   underline naming rule of database, compatible with python's camel naming rule for classes, which will convert to
#   underline naming rule automatically.
from typing import *
from util import camel_to_underline


def _member_inject(obj, *args, **kwargs):
    # inject entity variable to an instance by attribute injection, according to the given __FIELDS__
    assert isinstance(obj, Entity), 'Object should be an instance of Entity class'
    obj_type = type(obj)
    fields = getattr(obj_type, '_member_inject_field_name')
    field_dict = getattr(obj_type, '_member_inject_field_dict')
    set_fields = set()
    # check arguments
    if len(args) + len(kwargs) > len(fields):
        raise ValueError('Input argument count mismatch, expect: %d, got %d (args) and %d (kwargs)' %
                         (len(fields), len(args), len(kwargs)))
    for i in range(len(args)):
        set_fields.add(fields[i])
        setattr(obj, fields[i], args[i])
    expected_fields = set(fields)
    for key in kwargs:
        if key not in expected_fields:
            raise ValueError('Unexpected field %s' % key)
        if key in set_fields:
            raise ValueError('Field %s has already set' % key)
        set_fields.add(key)
        setattr(obj, key, kwargs[key])
    # check not null fields
    not_null_fields = set([x.field_name for x in obj_type.__FIELDS__ if type(x) == TableFieldDescriptor
                           and (x.not_null or x.primary_key) and x.default is None and not x.auto_increment])
    missing_fields = not_null_fields.difference(set_fields)
    if len(missing_fields) > 0:
        raise ValueError('Missing following not null fields: %s' % ', '.join(missing_fields))
    # add null fields
    null_fields = expected_fields.difference(set_fields)
    for field in null_fields:
        default_value = field_dict[field].default
        setattr(obj, field, default_value)


class ConstraintError(Exception):
    pass


def _check_constraint(cls: Type['Entity']):
    # todo: implement constraint check
    assert type(cls.__TABLE_NAME__) == str, '__TABLE_NAME__ field of any sub-class of Entity should be a string'
    if len(cls.__TABLE_NAME__) == 0:
        cls.__TABLE_NAME__ = camel_to_underline(cls.__name__)
    assert type(cls.__FIELDS__) == list, '__FIELDS__ field of any sub-class of Entity should be a list'
    assert all([isinstance(x, AbstractTableDescriptor) for x in cls.__FIELDS__]), \
        'All element in __FIELDS__ should be a sub-class of AbstractTableDescriptor'
    # primary key constraint check
    primary_key_implicitly_described = False
    primary_key_explicitly_described = False
    for fields in cls.__FIELDS__:
        if type(fields) == MultiPrimaryKeyOrderDescriptor:
            if primary_key_implicitly_described:
                raise ConstraintError('This entity class has declared implicit primary key (as field decorator)')
            elif primary_key_explicitly_described:
                raise ConstraintError('This entity class can declare one explicit primary key')
            primary_key_explicitly_described = True
        elif type(fields) == TableFieldDescriptor and fields.primary_key:
            if primary_key_explicitly_described:
                raise ConstraintError('This entity class has declared explicit primary key, '
                                      'primary key field decorator is not allowed')
            elif primary_key_implicitly_described:
                raise ConstraintError('This entity class has declared implicit primary key (as field decorator),'
                                      ' do not describe twice')
            primary_key_implicitly_described = True


class Entity:
    __FIELDS__ = []
    __TABLE_NAME__ = ''
    EntityClass = []  # tracks all sub-class of Entity

    @classmethod
    def __init_subclass__(cls, **kwargs):
        cls.EntityClass.append(cls)
        _check_constraint(cls)
        basic_fields = [x for x in cls.__FIELDS__ if type(x) == TableFieldDescriptor]
        field_dict = dict([(x.field_name, x) for x in basic_fields])
        setattr(cls, '_member_inject_field_dict', field_dict)
        setattr(cls, '_member_inject_field_name', [x.field_name for x in basic_fields])
        pkey = [x.field_name for x in basic_fields if x.primary_key]
        if len(pkey) == 0:
            pkey = [x for x in cls.__FIELDS__ if type(x) == MultiPrimaryKeyOrderDescriptor][0].primary_key_orders
        setattr(cls, '_member_inject_field_primary', pkey)

    def __init__(self, *args, **kwargs):
        _member_inject(self, *args, **kwargs)

    def __repr__(self):
        return '<Entity "%s" for table "%s": %s>' % (type(self).__name__, self.__TABLE_NAME__, str(self.__dict__))

    def __eq__(self, other):
        if not type(self) == type(other):
            return False
        fields = getattr(self, '_member_inject_field_name')
        for field in fields:
            field_val = getattr(self, field)
            if not hasattr(field_val, '__ne__'):
                raise RuntimeError('Field %s (value type: %s) of Entity class %s does not support "!=" operation' %
                                   (field, type(field_val).__name__, type(self).__name__))
            if field_val != getattr(other, field):
                return False
        return True

    # disable reference hint for pycharm
    def __getattr__(self, item):
        return object.__getattribute__(self, item)


class AbstractTableDescriptor:
    def __repr__(self):
        return '<TableField (abstract)>'

    def __str__(self):
        return self.__repr__()


# basic fields
class TableFieldDescriptor(AbstractTableDescriptor):
    def __init__(self, field_name: str, field_type: str, not_null: bool = False, unique: bool = False,
                 primary_key: bool = False, auto_increment: bool = False, default: Optional[Any] = None):
        self.field_name = field_name
        self.field_type = field_type
        self.not_null = not_null
        self.unique = unique
        self.primary_key = primary_key
        self.auto_increment = auto_increment
        self.default = default

    def __repr__(self):
        attr = ' '.join([x for x in ['not_null', 'unique', 'primary_key', 'auto_increment'] if getattr(self, x)])
        return '<TableFieldDescriptor %s: %s%s>' % (self.field_name, self.field_type,
                                                    '' if len(attr) == 0 else ' (%s)' % attr)


# specify the order of primary key explicitly, or use the declaration order implicitly
class MultiPrimaryKeyOrderDescriptor(AbstractTableDescriptor):
    def __init__(self, *primary_key_orders: str):
        self.primary_key_orders = primary_key_orders

    def __repr__(self):
        return '<MultiPrimaryKeyOrderDescriptor : %s>' % ', '.join(self.primary_key_orders)


# foreign key constraint for table
class ForeignKeyDescriptor(AbstractTableDescriptor):
    def __init__(self, field_name: str, ref_table_name: str, ref_table_field_name: Optional[str] = None):
        self.field_name = field_name
        self.ref_table_name = ref_table_name
        self.ref_table_field_name = ref_table_field_name

    def __repr__(self):
        return '<ForeignKeyDescriptor: %s -> %s%s>' % \
               (self.field_name, self.ref_table_name,
                '' if self.ref_table_field_name is None else '(%s)' % self.ref_table_field_name)


class TableIndexDescriptor(AbstractTableDescriptor):
    def __init__(self, index_name: str, *index_fields: str):
        self.index_name = index_name
        self.index_fields = index_fields

    def __repr__(self):
        return '<TableIndexDescriptor %s on field %s>' % (self.index_name, ', '.join(self.index_fields))
